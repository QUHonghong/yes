1. 仅在线程函数 PrintHello 中调用 pthread_exit(NULL);
在这种情况下，每个线程在完成其任务（即打印线程ID）后，都会通过调用 pthread_exit(NULL); 来正确地退出。这是线程退出的标准方式，它确保线程的资源被正确释放。

main 函数中的 pthread_exit(NULL); 将被忽略，因为 main 函数应该通过返回整数来结束，而不是调用 pthread_exit()。然而，在这个特定的程序中，由于 main 函数中没有返回语句，它实际上会隐式地返回0（这是C++标准的规定），然后程序结束。尽管这样不会造成错误，但最好还是在 main 函数的末尾加上一个显式的 return 0;。

输出顺序：线程的输出顺序是不确定的，因为线程是并发执行的。

2. 仅在 main 函数中调用 pthread_exit(NULL);
如果在线程函数 PrintHello 中不调用 pthread_exit(NULL);，而是在 main 函数中调用它，那么会发生什么呢？

首先，每个线程都会执行 cout<<"hello 线程ID"<<tid<<endl;，但之后它们不会通过 pthread_exit() 退出。这意味着这些线程将继续执行，尽管它们的函数已经到达了末尾。然而，由于函数末尾之后没有更多的代码要执行，这些线程实际上会处于一种“僵尸”状态，直到 main 函数结束并且整个进程被终止。

当 main 函数调用 pthread_exit(NULL); 时，它会通知线程库 main 线程已经退出，但这并不会立即终止其他线程。然而，由于整个进程即将结束（因为 main 函数已经退出），所有其他线程也将被强制终止。

输出顺序：同样是不确定的，因为线程是并发执行的。但是，由于线程没有正确退出，这种行为可能更加不可预测，并且可能导致资源泄露。

3. 在线程函数和 main 函数中都调用 pthread_exit(NULL);
这是您当前代码的情况。每个线程在完成其任务后都会调用 pthread_exit(NULL); 来正确退出，同时 main 函数也会调用它。然而，正如之前提到的，main 函数中的 pthread_exit(NULL); 是不必要的，并且应该被替换为一个显式的 return 0;。

输出顺序：仍然是不确定的，因为线程是并发执行的。但是，由于线程正确地退出了，程序的行为将更加可预测，并且资源将被正确释放。